import{j as e}from"./jsx-runtime-D_zvdyIk.js";import{useMDXComponents as l}from"./index-CePRvBtH.js";import{M as n,T as a,S as s,D as m,P as p,C as c,a as t,b as h}from"./index-UFm6KxWd.js";import{T as d,S as b,a as u,b as T,M as x,L as y,c as j,W as w}from"./Table.stories-CrUBxK09.js";import"./index-DmM0KDA7.js";import"./iframe-B_2duqtn.js";import"./index-D_Kw7eWP.js";import"./index-nLeaPAJ8.js";import"./index-CXQShRbs.js";import"./index-DrFu-skq.js";import"./index-D1pa-M5k.js";import"./cssprops-BO85xpNm.js";import"./index-CyCRagT9.js";import"./index-CmTRtbgT.js";import"./index-DLW06VQL.js";import"./index-BDzxygkP.js";import"./index-SU87TpAq.js";import"./helpers-DnLJB5bk.js";import"./styled-components.browser.esm-S-CusIP4.js";import"./Collection-cZH6f0Bi.js";import"./CollectionBuilder-DglRgqo3.js";import"./useFocusable-B7cTVP20.js";import"./useObjectRef-BO7mrmvR.js";import"./SSRProvider-nIDwi1ZO.js";import"./scale-CqCDTNu0.js";import"./Table.component-CBCyEO8a.js";import"./filterDOMProps-CeZl_uWj.js";import"./useSelectableItem-C-hNvN1k.js";import"./usePress-Cng8MYxN.js";import"./useEvent-Qm4q9YOK.js";import"./scrollIntoView-DuDju04b.js";import"./isScrollable-BSEN4xi5.js";import"./FocusScope-CLRP0VYY.js";import"./context-BF7eBGFA.js";import"./useDescription-CP-qk7_s.js";import"./useHighlightSelectionDescription-DKPvJoA_.js";import"./LiveAnnouncer-CeCcBDbP.js";import"./useUpdateEffect-gxShzMif.js";import"./useLocalizedStringFormatter-BJB32GAh.js";import"./useFocusRing-BmyBc2tX.js";import"./useFocusWithin-C-e8UI97.js";import"./useRenderProps-BzxgHqRb.js";import"./index-CrEZfznw.js";import"./useCollectionRenderer-BeqeLBJu.js";import"./useControlledState-sJfMLWrs.js";import"./index-CqJC2f1M.js";import"./mixins-BOHXBJW9.js";import"./ComboInput.component-ChwLRff1.js";import"./ComboInput.styles-Cjo-Ms-Y.js";import"./ComboInput.context-Di7U2yCG.js";import"./Input.component-BXixClzz.js";import"./Input.context-BTEI3GdY.js";import"./SkeletonLoader.component-D5bJtYsa.js";import"./getScrollParent-BL0kfGii.js";import"./Checkbox.component-BNvZm4Yj.js";import"./useFormValidationState-CKAS44yz.js";import"./useFormValidation-CsrNRCZi.js";import"./useToggle-nYxxvtGk.js";import"./useFormReset-DvzwwQm6.js";import"./Inputs.styles-Couh86OD.js";import"./TextField.component-BomPUKVc.js";import"./useTextField-B3HDaRNl.js";import"./useField-BhG43OVF.js";import"./useLabel-B1sX0IQZ.js";import"./useLabels-D0NjiLiF.js";import"./Field.styles-BmW9vKT0.js";import"./Provider-op_UCnZE.js";import"./Label.context-8YwVGsEO.js";import"./Message.context-4_rHhebz.js";import"./ErrorMessage.context-D-RNFvKn.js";import"./TextArea.context-D8jqO_QU.js";import"./NumberField.component-CnWOKK9F.js";import"./useNumberFormatter-CH8tnwcW.js";import"./NumberFormatter-DNR9MAW-.js";import"./useSpinButton-DrJLqD1D.js";import"./ProgressCircle.component-D57_vbeK.js";import"./colors-x_YFGAop.js";import"./IconButton.component-blxnUvMB.js";import"./Button.component-DRJR9m07.js";import"./useButton-CBzhh6F5.js";import"./useLink-BTwsTyp1.js";import"./SpinnerLoader.component-uF9SY2FS.js";import"./Loader.component-C9UWSKIc.js";import"./Flex.component-CUA2hDLx.js";import"./layout-ez2uQdt_.js";import"./utils-DqmNl-Il.js";import"./Checkmark.component-CRE6wLUH.js";import"./Spinner.component-BQyrLFoY.js";import"./MaterialIcon.component-DZmnA2mz.js";import"./Icons.styles-T5NoJEsB.js";import"./RequiredMarker-CwAzCIB3.js";import"./Message.component-D8ICG7W9.js";import"./ErrorMessage.component-BVX2wl3L.js";import"./DOMLayoutDelegate-Dsrs9r60.js";import"./useCollator-DZEoqIyA.js";import"./useHasTabbableChild-5m2xZxEz.js";import"./Pagination.component-BqMYHeX_.js";import"./CustomSelect.component-TdnTqWWG.js";import"./FloatingFieldInputWrapper-BYUYsVjJ.js";import"./Label.component-Bux1bQyn.js";import"./Dropdowns.styles-c5wm-1S0.js";import"./SelectField.component-1RJP0cG0.js";import"./useSelectableList-Ca_ZI4zK.js";import"./useMenuTrigger-Cre1gTLs.js";import"./useOverlayTrigger-BaVZjogA.js";import"./useCloseOnScroll-CkGkhb-Y.js";import"./VisuallyHidden-Yvqu08fX.js";import"./PressResponder-CHEeukYG.js";import"./context-DYfCRJJJ.js";import"./Popover.context-CkZWeej5.js";import"./DropdownButton-Cu0B0cJS.js";import"./useOverlayTriggerState-BxLf_MI7.js";import"./useSingleSelectListState-CT1HfnY0.js";import"./useListState-BOwdsj8-.js";import"./ListBox.component-Co4ZNLx6.js";import"./getItemCount-C96_vkqw.js";import"./useHover-WxTHsieF.js";import"./useForwardedRef-BWfLegUW.js";import"./Divider.component-Bpnxmsv4.js";import"./Popover.component-BFqnB8tM.js";import"./useOverlayPosition-DAZA0ZVA.js";function i(r){const o={code:"code",h3:"h3",h4:"h4",p:"p",...l(),...r.components};return e.jsxs(e.Fragment,{children:[e.jsx(n,{of:d}),`
`,e.jsx(a,{}),`
`,e.jsx(s,{}),`
`,e.jsx(m,{}),`
`,e.jsx(p,{}),`
`,e.jsx(c,{}),`
`,e.jsx(o.h3,{id:"sortable-table",children:"Sortable Table"}),`
`,e.jsx(t,{of:b,source:{language:"tsx",code:`

export default function SortableTable() {
  const [sortDescriptor, setSortDescriptor] = useState<SortDescriptor>({
    column: "name",
    direction: "ascending",
  });

  const pokemons = [
    {
      name: "Charizard",
      type: "Fire, Flying",
      level: 67,
    },
    {
      name: "Blastoise",
      type: "Water",
      level: 56,
    },
    {
      name: "Venusaur",
      type: "Grass, Poison",
      level: 83,
    },
    {
      name: "Pikachu",
      type: "Electric",
      level: 100,
    },
  ];

  const sortedPokemons = pokemons.sort((a, b) => {
    if (sortDescriptor.column === undefined) return 0;

    if (sortDescriptor.direction === "ascending") {
      return a[sortDescriptor.column] > b[sortDescriptor.column] ? 1 : -1;
    } else {
      return a[sortDescriptor.column] < b[sortDescriptor.column] ? 1 : -1;
    }
  });

  return (
    <Table
      aria-label="Table with sorting"
      sortDescriptor={sortDescriptor}
      onSortChange={setSortDescriptor}
    >
      <Table.Header>
        <Table.Column key="name" allowsSorting>
          Name
        </Table.Column>
        <Table.Column key="type" allowsSorting>
          Type
        </Table.Column>
        <Table.Column key="level" allowsSorting>
          Level
        </Table.Column>
      </Table.Header>
      <Table.Body items={sortedPokemons}>
        {(pokemon) => (
          <Table.Row key={pokemon.name}>
            <Table.Cell>{pokemon.name}</Table.Cell>
            <Table.Cell>{pokemon.type}</Table.Cell>
            <Table.Cell>{pokemon.level}</Table.Cell>
          </Table.Row>
        )}
      </Table.Body>
    </Table>
  );
}

`}}),`
`,e.jsx(o.h3,{id:"searchable-table-columns",children:"Searchable Table Columns"}),`
`,e.jsxs(o.p,{children:["You can make any column in the table searchable by setting the ",e.jsx(o.code,{children:"allowsSearching"})," prop to ",e.jsx(o.code,{children:"true"})," on that column."]}),`
`,e.jsx(o.p,{children:"If multiple columns are searchable, selecting a new column to search by will clear the current search term. Closing the search input will also clear the search term."}),`
`,e.jsx(t,{of:u,source:{language:"tsx",code:`
function SearchableTable() {
  const [searchDescriptor, setSearchDescriptor] = useState<SearchDescriptor>({
    column: null,
    search: "",
  });

  const pokemons = [
    {
      name: "Charizard",
      type: "Fire, Flying",
      level: 67,
    },
    {
      name: "Blastoise",
      type: "Water",
      level: 56,
    },
    {
      name: "Venusaur",
      type: "Grass, Poison",
      level: 83,
    },
    {
      name: "Pikachu",
      type: "Electric",
      level: 100,
    },
  ];

  const filteredPokemon = pokemons.filter((pokemon) => {
    if (!searchDescriptor.search || !searchDescriptor.column) return true;

    return pokemon[searchDescriptor.column]
      .toLowerCase()
      .includes(searchDescriptor.search.toLowerCase());
  });

  return (
    <div
      style={{
        padding: "16px",
      }}
    >
      <Table
        searchDescriptor={searchDescriptor}
        onSearchChange={setSearchDescriptor}
        {...props}
      >
        <Table.Header>
          <Table.Column key="name" allowsSearching>
            Name
          </Table.Column>
          <Table.Column key="type" allowsSearching width={200}>
            Type
          </Table.Column>
          <Table.Column key="level" width={100}>
            Level
          </Table.Column>
        </Table.Header>
        <Table.Body items={filteredPokemon}>
          {(pokemon) => (
            <Table.Row key={pokemon.name}>
              <Table.Cell>{pokemon.name}</Table.Cell>
              <Table.Cell>{pokemon.type}</Table.Cell>
              <Table.Cell>{pokemon.level}</Table.Cell>
            </Table.Row>
          )}
        </Table.Body>
      </Table>
    </div>
  );
}
`}}),`
`,e.jsx(o.h3,{id:"table-with-row-selection",children:"Table with Row Selection"}),`
`,e.jsxs(o.p,{children:["The table component supports row selection. By default, the selected rows are managed internally, but you can also provide ",e.jsx(o.code,{children:"selectedKeys"})," and ",e.jsx(o.code,{children:"onSelectionChange"})," props to manage the selected rows externally."]}),`
`,e.jsx(o.p,{children:"The table supports two types of row selection: 'single' and 'multiple'."}),`
`,e.jsx(o.h4,{id:"single-selection",children:"Single Selection"}),`
`,e.jsx(o.p,{children:"In single selection mode, only one row can be selected at a time."}),`
`,e.jsx(t,{of:T}),`
`,e.jsx(o.h4,{id:"multiple-selection",children:"Multiple Selection"}),`
`,e.jsx(o.p,{children:"In multiple selection mode, multiple rows can be selected at the same time. Or all rows can be selected by clicking the checkbox in the header."}),`
`,e.jsxs(o.p,{children:["Note that selecting all rows sets ",e.jsx(o.code,{children:"selectedKeys"})," to ",e.jsx(o.code,{children:'"all"'}),", so you can handle either selecting a single page or all rows in your application."]}),`
`,e.jsx(t,{of:x}),`
`,e.jsx(o.h3,{id:"loading-states",children:"Loading States"}),`
`,e.jsx(o.p,{children:"The table component supports two loading variants. The first is for when the columns of the table are known but the content is not."}),`
`,e.jsx(o.p,{children:"This is almost always the one you want."}),`
`,e.jsx(t,{of:y}),`
`,e.jsxs(o.p,{children:["In cases where you don't know the columns or the content of the table, you can use ",e.jsx(o.code,{children:"<Table.Skeleton />"}),"."]}),`
`,e.jsx(t,{of:j}),`
`,e.jsx(o.h3,{id:"table-bottom",children:"Table Bottom"}),`
`,e.jsxs(o.p,{children:["The ",e.jsx(o.code,{children:"Table.Bottom"})," component can be used to render a visual footer for the table. It is not actually a footer in the DOM, but rather a visual footer that is rendered at the bottom of the table. This allows it to be made sticky."]}),`
`,e.jsx(t,{of:w}),`
`,e.jsx(h,{})]})}function Io(r={}){const{wrapper:o}={...l(),...r.components};return o?e.jsx(o,{...r,children:e.jsx(i,{...r})}):i(r)}export{Io as default};
